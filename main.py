"""
Module main.py
==============

This module contains the game loop and event handling code
"""
import logging
import math
import os
import pprint
import sys
from typing import Any, Callable, Union

import pygame.locals as pygl

from src.board import *
from src.constants import *
from src.player import Player

__version__ = '0.1'
__author__ = 'Eric G.D'

os.environ['PYGAME_HIDE_SUPPORT_PROMPT'] = 'True'
os.environ['SDL_VIDEO_CENTERED'] = 'True'

logging.basicConfig(filemode='a',
                    filename=str(log_path),
                    format='%(asctime)s - %(levelname)s - %(message)s',
                    level=logging.INFO)


def generate_resolutions(res: ResDict = None) -> ResDict:
    """
    Generates a dictionary that contains the resolutions of each asset relative to the window size
    :param res: The dictionary of resolutions to be updated
    :return: A reference to :res:
    """
    info = pygame.display.Info()
    current_res = info.current_w, info.current_h
    if not res:
        res = {}
    screen, window = (current_res, tuple(x // 2 for x in current_res)) \
        if pygame.display.get_surface() is None or 'screen' not in res.keys() else (res['screen'], current_res)
    token = (math.gcd(*window),) * 2
    res.update({
        'screen': screen,
        'window': window,
        'margin': tuple((window[i] - (BOARD_DIMENSIONS[1 - i] * token[i])) // 2 for i in range(2)),
        'token': token,
        'board': token
    })
    logging.debug('Resolution dictionary updated.')
    logging.debug(f'resolutions = {pprint.pformat(res)}')
    return res


def generate_images(res: ResDict, imgs: ImageDict = None) -> ImageDict:
    """
    Loads assets from ASSETS_PATH into surface objects scaled by the resolutions from :resolutions:
    :param res:     Resolutions dictionary generated by generate_resolutions
    :param imgs:    The dictionary to save the surface objects to
    :return: A reference to :imgs:
    """
    if not imgs:
        keys = tuple(res.keys())[3:]  # Ignore screen, display and margin
        imgs = {key: {} for key in keys}
    for f in ASSETS_PATH.glob('*.png'):
        if f == icon_path:
            continue
        prefix, suffix = f.stem.split('_')
        if prefix in imgs.keys():
            imgs[prefix][suffix] = load_image(f, res[prefix])
    logging.debug('Image dictionary updated.')
    logging.debug('imgs = %s' % str(imgs))
    return imgs


def load_image(file_name: Path, res: Resolution = None) -> pygame.Surface:
    """
    :param file_name:   The path of an image in ASSETS_PATH
    :param res:         The desired resolution, the image will be left at it's original resolution if res is False-like
    :return: A surface object representing :file_name: scaled by :res:
    """
    img = pygame.image.load(str(file_name)).convert_alpha()
    logging.debug(f'Loaded {file_name}.')
    return pygame.transform.scale(img, res) if res else img


def setup_video() -> Tuple[pygame.Surface, pygame.font.Font]:
    """
    Initialises PyGame video system and everything else related to the GUI
    :return: The game window as a Surface object and the main font object
    """
    pygame.init()
    Board.resolutions = generate_resolutions(Board.resolutions)
    display = pygame.display.set_mode(Board.resolutions['window'])
    pygame.display.set_caption(title)
    pygame.display.set_icon(load_image(icon_path))
    Board.images = generate_images(Board.resolutions, Board.images)
    Board.clock = pygame.time.Clock()
    display.fill(Colors.background)
    pygame.display.update()
    Board.clock.tick()
    font = pygame.font.Font(str(ASSETS_PATH / 'visitor.ttf'), min(Board.resolutions['window']) // 10)
    return display, font


def player_menu() -> Tuple[Player, Player]:
    """
    :return: A tuple of players, customised by the user
    """
    # TODO: Make a menu that allows the user to customise the players
    return Player(1, 'red', True), Player(2, 'yellow', True)


def end_message(winner: Player = None) -> None:
    """
    Shows an end-game message
    :param winner:  The player that won
    :return: Nome
    """
    # TODO: Implement function
    pass


def draw_fps_counter(surface: pygame.Surface, font: pygame.font.Font, clock: 'pygame.time.Clock') -> None:
    """
    Shows an fps counter in the top-left corner of :surface:
    :param surface: The surface to blit the counter onto
    :param font:    The font used to render the counter
    :param clock:   The program's clock
    :return: None
    """
    counter = font.render(str(int(clock.get_fps())), False, Colors.white)
    rect = counter.get_rect()
    rect.topleft = (0, 0)
    surface.fill(Colors.background, rect)
    surface.blit(counter, rect)
    pygame.display.update(rect)


def exit_game():
    """
    Exits the program
    :return: None
    """
    logging.info(LOG_MESSAGE.format('###', 'END OF PROGRAM'))
    pygame.quit()
    sys.exit()


def handle_events(board: Board, on_click: Callable[[Board, Position], Any] = None) -> Any:
    """
    Handles all events relevant to the game
    :param board:       The game board
    :param on_click:    The function to call if a click was registered
    :return: The return value of :on_click: if it was specified and a MOUSEBUTTONUP event was handled, None otherwise
    """
    last_click = None
    queue = pygame.event.get() if pygame.event.peek() else (pygame.event.wait(),)
    # If there are no events then there is no need to keep running the game loop

    switch = {
        pygl.QUIT: exit_game,
        pygl.MOUSEMOTION: board.set_extra_token,
        pygl.MOUSEBUTTONUP: pygame.mouse.get_pos
    }

    for event in queue:
        val = switch.get(event.type, lambda *args: None)()
        last_click = val if isinstance(val, tuple) else last_click
    return on_click(board, last_click) if last_click and on_click else last_click


def human_turn(board: Board, mouse_pos: Position) -> int:
    """
    Callback function that runs a human's turn after the board was clicked
    :param board:       The game board
    :param mouse_pos:   The position of the last mouse click
    :return: The index of the column that was clicked if the board was clicked, -1 otherwise
    """
    out = -1
    if mouse_pos and all(Board.resolutions['margin'][i] <
                         mouse_pos[i] <
                         Board.resolutions['window'][i] - Board.resolutions['margin'][i]
                         for i in range(2)):  # If the board was clicked
        column = (mouse_pos[0] - Board.resolutions['margin'][0]) // Board.resolutions['token'][0]
        assert 0 <= column < board.cols
        out = column if not board.column_full(column) else out
    return out


def game_loop(display: pygame.Surface, font: pygame.font.Font, players: Tuple[Player, Player]) -> Union[Player, None]:
    """
    The main game loop
    :param display: The game window's surface object
    :param font:    The font object used to render messages
    :param players: A tuple containing all of the players
    :return: The player that won the current game
    """
    board = Board(ROWS, COLS, players)
    board.draw(display, FPS)
    winner = None
    in_game = True
    while in_game:
        current_player = board.get_current_player()
        mouse = handle_events(board)
        column = human_turn(board, mouse) if current_player.is_human else board.negamax()
        if column != -1:
            board.insert(display, column, current_player.color)
        winning_player = board.get_winning_player()
        if winning_player is not None or board.is_full():
            winner = winning_player
            in_game = False
        board.draw(display, FPS, extra_token=current_player.color)
        # draw_fps_counter(display, font, Board.clock)
    return winner


def main() -> None:
    """
    The program's main function
    :return: None
    """
    logging.info(LOG_MESSAGE.format('###', 'START OF PROGRAM'))
    display, font = setup_video()
    players = player_menu()
    while True:
        winner = game_loop(display, font, players)
        if winner is not None:
            winner.score += 1
            logging.info(f'# {winner!s} wins!')
            logging.debug(', '.join(f'{player!s}: {player.score}' for player in players))
        else:
            logging.info("# It's a tie!")
        # end_message(winner)
        logging.info(LOG_MESSAGE.format('##', 'Starting new game...'))


if __name__ == '__main__':
    try:
        main()
    except Exception:
        logging.exception('Uncaught exception:')
        logging.info(LOG_MESSAGE.format('###', 'END OF PROGRAM'))
        raise
